# 2.2 基础场景能力

在完成Cursor的安装和配置后，我们可以开始探索它提供的各种基础AI能力。这些能力覆盖了日常开发中的常见场景，大大提高了编码效率。

## 💡 智能补全代码（多行Tab预测）

Cursor提供了远超传统IDE自动补全的多行代码预测能力，这是最常用也是最直接提升效率的功能。

### 使用方法

1. 开始编写代码（如函数声明、注释等）
2. Cursor会自动显示灰色的建议代码
3. 按下`Tab`接受建议，或继续输入忽略建议
4. 也可以使用`Ctrl+→`（Windows/Linux）或`Cmd+→`（macOS）接受单词级别的补全

### 示例场景

假设你正在编写一个处理用户登录的函数：

```javascript
// 处理用户登录，验证凭证并返回JWT令牌
function loginUser(email, password) {
```

当你输入到这里时，Cursor可能会预测并显示类似如下的代码：

```javascript
  try {
    // 验证用户输入
    if (!email || !password) {
      return { success: false, message: "邮箱和密码不能为空" };
    }
    
    // 查找用户并验证密码
    const user = await User.findOne({ email });
    if (!user) {
      return { success: false, message: "用户不存在" };
    }
    
    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) {
      return { success: false, message: "密码错误" };
    }
    
    // 生成JWT令牌
    const token = jwt.sign(
      { id: user._id, email: user.email },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    return { success: true, token, user: { id: user._id, email: user.email } };
  } catch (error) {
    console.error("登录失败:", error);
    return { success: false, message: "服务器错误" };
  }
}
```

你可以通过按`Tab`键接受整个建议，或继续输入你自己的实现。

### 优化技巧

- **写清晰的函数名和注释**：帮助AI更准确理解你的意图
- **使用类型提示**（TypeScript或JSDoc）：增加补全的准确性
- **接受部分补全**：使用`Tab`接受正确部分，然后继续修改
- **善用连续补全**：接受一次补全后，常常能触发后续代码的预测

## 🧠 自然语言写函数/重写代码段

Cursor允许你使用自然语言描述来创建或修改代码，这对于实现新功能或重构现有代码特别有用。

### 使用方法

1. **创建新函数**：
   - 按下`Cmd+K`（macOS）或`Ctrl+K`（Windows/Linux）
   - 输入自然语言描述，如"创建一个将CSV文件解析为JSON对象数组的函数"
   - 按Enter，Cursor将生成相应函数

2. **重写代码段**：
   - 选中需要重写的代码
   - 按下`Cmd+K`（macOS）或`Ctrl+K`（Windows/Linux）
   - 输入重写指令，如"优化这段代码的性能"或"转换为async/await风格"
   - 按Enter，Cursor将重写选中的代码

### 示例场景

**场景1：创建新函数**

指令：
```
创建一个函数，用于过滤并排序产品列表，可以按价格区间过滤，并按评分或价格排序
```

Cursor可能生成：

```javascript
/**
 * 过滤并排序产品列表
 * @param {Array} products - 产品列表
 * @param {Object} filters - 过滤条件
 * @param {number} [filters.minPrice] - 最低价格
 * @param {number} [filters.maxPrice] - 最高价格
 * @param {string} sortBy - 排序字段，'price'或'rating'
 * @param {boolean} ascending - 是否升序，true为升序，false为降序
 * @return {Array} 过滤并排序后的产品列表
 */
function filterAndSortProducts(products, filters, sortBy = 'price', ascending = true) {
  // 过滤产品
  let filteredProducts = [...products];
  
  if (filters.minPrice !== undefined) {
    filteredProducts = filteredProducts.filter(product => product.price >= filters.minPrice);
  }
  
  if (filters.maxPrice !== undefined) {
    filteredProducts = filteredProducts.filter(product => product.price <= filters.maxPrice);
  }
  
  // 排序产品
  filteredProducts.sort((a, b) => {
    const valueA = a[sortBy];
    const valueB = b[sortBy];
    
    if (ascending) {
      return valueA - valueB;
    } else {
      return valueB - valueA;
    }
  });
  
  return filteredProducts;
}
```

**场景2：重写代码**

原代码：
```javascript
function getUsers() {
  return new Promise((resolve, reject) => {
    fetch('/api/users')
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(data => {
        resolve(data);
      })
      .catch(error => {
        reject(error);
      });
  });
}
```

指令：
```
转换为async/await语法，并添加错误处理
```

Cursor重写后：
```javascript
/**
 * 获取用户列表
 * @returns {Promise<Array>} 用户数据数组
 * @throws {Error} 当网络请求失败时抛出错误
 */
async function getUsers() {
  try {
    const response = await fetch('/api/users');
    
    if (!response.ok) {
      throw new Error(`Network response was not ok: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Failed to fetch users:', error);
    throw error;
  }
}
```

### 提示效果优化

- **具体明确**：提供清晰的需求和约束条件
- **包含示例**：给出输入/输出的例子
- **指定技术栈**：明确语言、框架或库的版本
- **分步骤**：复杂功能可以分步骤实现，逐步完善

## 🪛 自动修复报错 + 优化代码风格

Cursor能够识别代码中的错误并提供修复建议，同时还能优化代码风格，使其更符合最佳实践。

### 使用方法

1. **自动错误修复**：
   - 当代码中出现红色波浪线（语法错误）或编译错误时
   - 将光标放在错误处
   - 按下`Alt+F`（Windows/Linux）或`Option+F`（macOS）
   - 或者右键选择"AI: Fix"

2. **代码风格优化**：
   - 选中需要优化的代码段
   - 使用`Cmd+K`（macOS）或`Ctrl+K`（Windows/Linux）
   - 输入"优化这段代码的风格"或"根据[某规范]重构这段代码"

### 示例场景

**场景1：修复错误**

错误代码：
```javascript
function calculateTotal(items) {
  let total = 0;
  
  items.forEech((item) => {  // 拼写错误：forEach
    if (item.price > 0) {
      total += item.price * (item.quantity || 1);
    }
  }
  
  return total;  // 缺少右括号
}
```

使用`Option+F`或`Alt+F`，Cursor会识别并修复这些错误：

```javascript
function calculateTotal(items) {
  let total = 0;
  
  items.forEach((item) => {  // 修复拼写错误
    if (item.price > 0) {
      total += item.price * (item.quantity || 1);
    }
  });  // 添加缺少的右括号
  
  return total;
}
```

**场景2：优化代码风格**

原代码：
```javascript
var x = 10;
var y = 20;
var z = 30;
function doSomething(a,b,c){
if(a>b){
console.log("a is greater");
if(a>c){
return a;
}else{
return c;
}}else{
if(b>c){
return b;
}else{
return c;
}}}
```

使用代码风格优化指令后：
```javascript
const x = 10;
const y = 20;
const z = 30;

/**
 * 返回三个数中的最大值
 * @param {number} a - 第一个数
 * @param {number} b - 第二个数
 * @param {number} c - 第三个数
 * @returns {number} 最大值
 */
function doSomething(a, b, c) {
  if (a > b) {
    console.log("a is greater");
    
    if (a > c) {
      return a;
    } else {
      return c;
    }
  } else {
    if (b > c) {
      return b;
    } else {
      return c;
    }
  }
}
```

### 最佳实践

- **错误修复后检查**：AI修复可能不完美，修复后仍需检查
- **风格优化要有度**：过度优化可能导致代码可读性下降
- **与团队规范结合**：指定与团队一致的代码风格规范
- **使用ESLint/Prettier**：配合自动格式化工具使用

## 📋 自动生成测试代码/接口注释

Cursor可以为现有代码生成单元测试和API文档，大大减少这些必要但繁琐工作的时间。

### 使用方法

1. **生成测试代码**：
   - 选择要测试的函数或类
   - 按下`Cmd+K`（macOS）或`Ctrl+K`（Windows/Linux）
   - 输入"为这个函数生成单元测试"或具体的测试框架需求

2. **生成接口注释**：
   - 将光标放在函数或类定义处
   - 按下`Cmd+K`（macOS）或`Ctrl+K`（Windows/Linux）
   - 输入"为这个函数生成JSDoc注释"或其他文档格式

### 示例场景

**场景1：生成单元测试**

对于以下函数：
```javascript
function validateEmail(email) {
  const pattern = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
  return pattern.test(email);
}
```

测试生成指令：
```
使用Jest为这个邮箱验证函数生成单元测试，包括有效、无效和边界情况
```

Cursor可能生成：

```javascript
describe('validateEmail', () => {
  test('应该对有效邮箱返回true', () => {
    expect(validateEmail('user@example.com')).toBe(true);
    expect(validateEmail('user.name@example.co.uk')).toBe(true);
    expect(validateEmail('user-name@example-site.com')).toBe(true);
    expect(validateEmail('user123@example.org')).toBe(true);
  });

  test('应该对无效邮箱返回false', () => {
    expect(validateEmail('userexample.com')).toBe(false); // 缺少@
    expect(validateEmail('user@')).toBe(false); // 缺少域名
    expect(validateEmail('@example.com')).toBe(false); // 缺少用户名
    expect(validateEmail('user@example')).toBe(false); // 无效顶级域名
  });

  test('应该处理边界情况', () => {
    expect(validateEmail('')).toBe(false); // 空字符串
    expect(validateEmail('a@b.co')).toBe(true); // 最小有效邮箱
    expect(validateEmail(' user@example.com ')).toBe(false); // 包含空格
  });
});
```

**场景2：生成API文档注释**

对于以下函数：
```javascript
async function fetchUserOrders(userId, status, page = 1, limit = 10) {
  const response = await fetch(`/api/users/${userId}/orders?status=${status}&page=${page}&limit=${limit}`);
  if (!response.ok) {
    throw new Error('Failed to fetch orders');
  }
  return await response.json();
}
```

文档生成指令：
```
为这个函数生成JSDoc注释
```

Cursor可能生成：

```javascript
/**
 * 获取用户订单列表
 * @async
 * @param {string|number} userId - 用户ID
 * @param {string} status - 订单状态过滤条件（如'pending'、'completed'等）
 * @param {number} [page=1] - 页码，默认为1
 * @param {number} [limit=10] - 每页条目数，默认为10
 * @returns {Promise<Object>} 包含订单列表和分页信息的对象
 * @throws {Error} 当API请求失败时抛出错误
 * @example
 * // 获取用户ID为123的待处理订单的第一页
 * const orders = await fetchUserOrders(123, 'pending');
 */
async function fetchUserOrders(userId, status, page = 1, limit = 10) {
  // 函数实现...
}
```

### 技巧与提示

- **提供测试框架**：指定Jest、Mocha等测试框架
- **说明测试范围**：指明要测试的边界条件和特殊情况
- **指定文档格式**：明确需要JSDoc、TypeDoc或其他格式
- **补充缺失信息**：对于参数类型等缺失信息，AI可能需要猜测，应当审查和修正

## 📜 自动生成PR总结/diff解读

Cursor能够帮助开发者快速理解代码变更并生成高质量的提交信息和PR描述。

### 使用方法

1. **生成提交信息**：
   - 在Git暂存区添加变更后
   - 使用命令面板或快捷键打开Cursor AI
   - 输入"为当前变更生成commit信息"

2. **PR描述生成**：
   - 查看PR的diff内容
   - 使用Cursor AI功能
   - 输入"为这些变更生成PR描述"
   
3. **代码变更解释**：
   - 选择难以理解的代码变更
   - 使用Cursor AI功能
   - 输入"解释这段代码的变化及其影响"

### 示例场景

**场景1：提交信息生成**

对于以下变更：
- 修复了用户注册表单中的电子邮件验证逻辑
- 改进了表单提交后的错误处理
- 更新了相关的单元测试

生成指令：
```
为这些变更生成简洁明了的commit信息
```

Cursor可能生成：
```
fix: 修复用户注册表单的邮箱验证和错误处理

- 修复了邮箱格式验证的正则表达式逻辑
- 改进表单提交失败时的错误消息展示
- 更新并扩展了相关单元测试用例

Resolves: #123
```

**场景2：PR描述生成**

对于一个添加新功能的PR，生成指令：
```
为这个添加用户仪表盘功能的PR生成详细描述
```

Cursor可能生成：

```markdown
## 用户仪表盘功能实现

本PR实现了用户个人仪表盘功能，允许用户查看其账户摘要、近期订单和活动历史。

### 主要变更

- 新增用户仪表盘页面组件及路由配置
- 实现订单历史API接口及数据展示
- 添加账户活动时间轴组件
- 集成用户数据统计图表

### 技术细节

- 使用React Hooks管理仪表盘组件状态
- 实现数据懒加载以提高页面性能
- 添加响应式布局支持各种屏幕尺寸

### 测试

- 添加了组件单元测试，覆盖率>85%
- 实现E2E测试验证主要用户流程

### 屏幕截图

[这里可以添加功能截图]

### 相关问题

Closes #456, Relates to #789
```

### 最佳实践

- **清晰描述变更范围**：指定哪些文件或功能被修改
- **提供背景信息**：说明为什么需要这些变更
- **审查AI生成内容**：确保准确性，修改任何不准确的描述
- **添加相关上下文**：如相关的issue编号或设计文档链接

---

以上基础能力是日常开发中最常用的AI辅助功能。通过熟练掌握这些功能，开发者可以显著提高工作效率。在下一节中，我们将深入探讨如何编写高效的Prompt，以获得更精准的AI辅助效果。 